{"/College_Stuffs/MCimp":{"title":"MC imp notes (VipJet)","data":{"1-difference-between-microprocessor-and-microcontroller#1. Difference between Microprocessor and Microcontroller":"Parameter\tMicroprocessor\tMicrocontroller\tCircuit complexity\tThe circuit is complex due to external connection.\tMicrocontrollers are present on chip memory. The circuit is less complex.\tMemory and I/O components\tThe memory and I/O components are to be connected externally.\tThe memory and I/O components are available.\tCompact system compatibility\tMicroprocessors can’t be used in compact system.\tMicrocontrollers can be used with a compact system.\tEfficiency\tMicroprocessors are not efficient.\tMicrocontrollers are efficient.\tZero status flag\tMicroprocessors have a zero status flag.\tMicrocontroller doesn’t have a zero status flag.\tNumber of registers\tMicroprocessors have less number of registers.\tMicrocontrollers have more number of registers.\tApplications\tMicroprocessors are generally used in personal computers.\tMicrocontrollers are generally used in washing machines, and air conditioners.","2-avr-architecture#2) Avr Architecture":"The AVR architecture is a Harvard architecture, which means that it has separate memory buses for instructions and data. This allows the AVR to execute instructions and access data at the same time, which improves performance.The AVR CPU has 32 registers, each of which is 8 bits wide. The registers are used to store data and instructions. The CPU also has a 16-bit program counter, which is used to keep track of the current instruction being executed.The AVR has a number of peripherals, including timers, counters, I/O ports, and a serial communication interface. The peripherals can be used to control external devices, such as motors, sensors, and displays.The AVR is a powerful and versatile microcontroller that can be used to create a wide variety of embedded systems.Here are some additional details about the AVR architecture:Harvard architecture: A Harvard architecture is a type of computer architecture in which the instruction memory and data memory are separate. This allows the CPU to access instructions and data at the same time, which improves performance.32 registers: The AVR has 32 registers, each of which is 8 bits wide. The registers are used to store data and instructions.16-bit program counter: The program counter is a 16-bit register that is used to keep track of the current instruction being executed.Peripherals: The AVR has a number of peripherals, including timers, counters, I/O ports, and a serial communication interface. The peripherals can be used to control external devices, such as motors, sensors, and displays.","3-data-memory-organization#3) Data memory organization":"In AVR microcontrollers, data memory is divided into four parts:\nRegister file: This is a set of 32 registers that are used to store temporary values.\nI/O registers: These registers are used to control the AVR's ports and peripherals.\nExtended I/O registers: These registers are used to control the AVR's extended peripherals.\nInternal SRAM: This is a block of memory that can be used to store variables and data.\nThe register file is the fastest part of data memory, and it is used to store temporary values that are being used by the AVR's CPU. The I/O registers are used to control the AVR's ports and peripherals. The extended I/O registers are used to control the AVR's extended peripherals. Internal SRAM is the slowest part of data memory, but it is the largest. It can be used to store variables and data that need to be stored for a long period of time.The AVR's data memory is organized in a contiguous fashion. This means that all of the registers and memory locations are arranged in a single, continuous block of memory. This makes it easy to access data and registers, and it also makes it easy to calculate the address of a particular register or memory location.The AVR's data memory is also organized in a bank-based fashion. This means that the data memory is divided into a number of banks, and each bank can only be accessed by using a special bank select register. This is done to improve performance, as it allows the AVR to access data from multiple banks without having to switch banks in between accesses.The AVR's data memory is a powerful tool that can be used to store variables, data, and instructions. By understanding how the AVR's data memory is organized, you can use it to your advantage to create efficient and effective programs.","4-harvard-architecture#4) Harvard Architecture":"Harvard architecture is a type of computer architecture that separates the memory for instructions (program memory) from the memory for data. This allows the CPU to access instructions and data simultaneously, which can improve performance.The AVR microcontroller uses Harvard architecture. This means that the AVR has two separate memory spaces: program memory and data memory. Program memory stores the instructions that the AVR executes, while data memory stores the data that the AVR uses to execute those instructions.The AVR has two separate buses that connect the CPU to these two memory spaces: the program bus and the data bus. The program bus is used to transfer instructions from program memory to the CPU, while the data bus is used to transfer data from data memory to the CPU.Having separate buses for instructions and data allows the CPU to access instructions and data simultaneously. This is because the CPU can read instructions from program memory while it is also writing data to data memory. This can improve performance, as it allows the CPU to execute instructions and process data more quickly.Harvard architecture is a more complex type of computer architecture than Von Neumann architecture, which is the more common type of architecture. However, Harvard architecture can offer some performance advantages in certain applications.Here are some of the advantages of Harvard architecture:\nIncreased performance: Harvard architecture can improve performance by allowing the CPU to access instructions and data simultaneously.\nReduced latency: Harvard architecture can reduce latency by allowing the CPU to start fetching the next instruction before the current instruction has finished executing.\nIncreased flexibility: Harvard architecture can increase flexibility by allowing the CPU to use different types of memory for instructions and data.\nHere are some of the disadvantages of Harvard architecture:\nIncreased complexity: Harvard architecture is more complex than Von Neumann architecture.\nIncreased cost: Harvard architecture is more expensive than Von Neumann architecture.\nReduced compatibility: Harvard architecture is not compatible with all software.","5avr-family#5)Avr Family":"The AVR family is a group of microcontrollers developed by Atmel, now owned by Microchip Technology. They are modified Harvard architecture 8-bit RISC single-chip microcontrollers. AVR was one of the first microcontroller families to use on-chip flash memory for program storage, as opposed to one-time programmable ROM, EPROM, or EEPROM used by other microcontrollers at the time.The AVR family is divided into several types, each with its own set of features and capabilities. The main types of AVR microcontrollers are:\nATmega: The ATmega family is the most popular type of AVR microcontroller. It offers a wide range of features and capabilities, including a variety of on-chip peripherals, a high clock speed, and a low power consumption.\nATtiny: The ATtiny family is a smaller and less expensive type of AVR microcontroller. It is designed for applications where space and cost are critical.\nATxmega: The ATxmega family is a high-performance type of AVR microcontroller. It offers features and capabilities that are not available in the ATmega or ATtiny families, such as a larger number of on-chip peripherals, a faster clock speed, and a wider range of operating voltages.\nIn addition to the main types of AVR microcontrollers, there are also a number of specialized types, such as the following:\nAVR DA: The AVR DA family is designed for applications that require high-speed data acquisition. It features a 12-bit ADC and a 10-bit DAC.\nAVR DD: The AVR DD family is designed for applications that require a high degree of integration. It features a wide range of on-chip peripherals, including a USB controller, a Ethernet controller, and a CAN controller.\nThe AVR family is a popular choice for a wide range of applications, including:\nHome automation: AVR microcontrollers are often used in home automation devices, such as light switches, thermostats, and security systems.\nIndustrial automation: AVR microcontrollers are also used in industrial automation devices, such as motor controllers, PLCs, and robots.\nConsumer electronics: AVR microcontrollers are used in a wide range of consumer electronics devices, such as MP3 players, digital cameras, and printers.\nThe AVR family is a powerful and versatile platform for embedded systems development. It offers a wide range of features and capabilities, making it a good choice for a wide range of applications.","6features-of-avr#6)Features of avr":"Harvard architecture\n32 registers\n16-bit program counter\nPeripherals\nSmall size\nLow power consumption\nHigh performance\nFlexibility","7-explain-get-data-from-ports-and-send-data-to-ports-in-avr#7) Explain get data from ports and send data to ports in avr":"Here is a simpler explanation of how to get data from ports and send data to ports in AVR:\nTo get data from a port, use the PINx register. For example, to get data from port B, use the PINB register.\nTo send data to a port, use the PORTx register. For example, to send data to port B, use the PORTB register.\nThe PINx and PORTx registers are 8-bit registers. This means that they can store up to 256 different values.\nThe bits in the PINx and PORTx registers correspond to the port pins. For example, bit 0 in the PINB register corresponds to pin 0 on port B.\nTo read data from a port, simply assign the PINx register to a variable. For example, to read data from port B and store it in the variable data, use the following code:\nCode snippet\ndata = PINB;\nTo write data to a port, simply assign a variable to the PORTx register. For example, to write the value of the variable data to port B, use the following code:\nCode snippet\nPORTB = data;\nIt is important to note that the data direction of the port must be set to input before reading data from the port, and the data direction must be set to output before writing data to the port.\nTo set the data direction of a port to input, set the corresponding bit in the DDRx register to 0. For example, to set port B to input, use the following code:\nCode snippet\nDDRB = 0;\nTo set the data direction of a port to output, set the corresponding bit in the DDRx register to 1. For example, to set port D to output, use the following code:\nCode snippet\nDDRD = 0xFF;","8explain-bit-manipulation-commands-in-avr#8) Explain Bit manipulation commands in avr":"Bit manipulation is the act of changing individual bits in a byte or word. This can be done using a variety of operators, including the following:\nBitwise AND: The bitwise AND operator (&) will return a 1 if and only if both bits are 1.\nBitwise OR: The bitwise OR operator (|) will return a 1 if either bit is 1.\nBitwise NOT: The bitwise NOT operator (~) will invert the bits in a byte or word.\nBitwise XOR: The bitwise XOR operator (^) will return a 1 if and only if the bits are different.\nBit manipulation can be used to perform a variety of tasks, such as:\nSetting or clearing a bit: To set a bit, simply use the bitwise OR operator to OR a 1 with the bit's position. To clear a bit, simply use the bitwise AND operator to AND a 0 with the bit's position.\nTesting a bit: To test a bit, simply use the bitwise AND operator to AND the bit's position with a 1. If the result is 1, then the bit is set. If the result is 0, then the bit is cleared.\nShifting bits: To shift bits, simply use the bitwise shift operators (<< and >>). The bitwise left shift operator (<<) will shift the bits in a byte or word to the left by the specified number of positions. The bitwise right shift operator (>>) will shift the bits in a byte or word to the right by the specified number of positions.\nBit manipulation can be a powerful tool for programmers who want to optimize their code or perform complex operations on data. However, it is important to use bit manipulation carefully, as it can be easy to make mistakes.Here is an example of how to use bit manipulation to set a bit:Code snippet\n// Set bit 0 in the variable `data`\ndata |= 1;\nHere is an example of how to use bit manipulation to test a bit:Code snippet\n// Check if bit 0 in the variable `data` is set\nif (data & 1) {\n  // Bit 0 is set\n} else {\n  // Bit 0 is cleared\n}\nHere is an example of how to use bit manipulation to shift bits:Code snippet\n// Shift the bits in the variable `data` to the left by 1 position\ndata <<= 1;","9-explain-ascii-to-packed-bcd-in-avr#9) explain ascii to packed bcd in avr":"ASCII to packed BCD in AVR is a process of converting ASCII digits to packed BCD digits. Packed BCD digits are two-digit numbers that are stored in a single byte. ASCII digits are single-digit numbers that are stored in a single byte.To convert ASCII to packed BCD in AVR, you can use the following steps:\nMask the ASCII digit to remove the upper nibble.\nShift the masked ASCII digit left by 4 bits.\nCombine the shifted ASCII digit with the lower nibble of the ASCII digit.\nStore the resulting packed BCD digit in a byte.\nFor example, to convert the ASCII digit '4' to packed BCD, you would follow these steps:\nMask the ASCII digit '4' to remove the upper nibble. This gives you the value 0x04.\nShift the masked ASCII digit left by 4 bits. This gives you the value 0x10.\nCombine the shifted ASCII digit with the lower nibble of the ASCII digit. This gives you the value 0x14.\nStore the resulting packed BCD digit in a byte.\nThe resulting packed BCD digit is 0x14, which represents the number 14.Here is a simple AVR C program that converts ASCII to packed BCD:Code snippet\n#include <stdio.h>\nint main(void) {\n  unsigned char ascii_digit;\n  unsigned char packed_bcd;\n  // Get the ASCII digit from the user.\n  printf(\"Enter an ASCII digit: \");\n  scanf(\"%hhx\", &ascii_digit);\n  // Convert the ASCII digit to packed BCD.\n  packed_bcd = (ascii_digit & 0x0F) << 4 | (ascii_digit >> 4);\n  // Print the packed BCD digit.\n  printf(\"The packed BCD digit is: %02X\\n\", packed_bcd);\n  return 0;\n}\nThis program will first prompt the user to enter an ASCII digit. The user's input will be stored in the variable ascii_digit. The program will then convert the ASCII digit to packed BCD using the steps outlined above. The packed BCD digit will be stored in the variable packed_bcd. Finally, the program will print the packed BCD digit to the console.","10-explain-delay-in-c-and-its-type#10) explain delay in c and its type":"In C, the delay function is used to pause the execution of the program for a specified amount of time. The delay function takes two arguments: the first argument is the number of milliseconds to delay, and the second argument is the unit of time. The default unit of time is milliseconds, but you can also specify seconds or microseconds.For example, the following code will delay the program for 1 second:Code snippet\nvoid delay(unsigned int milliseconds) {\n  for (unsigned int i = 0; i < milliseconds; i++) {\n    // Do nothing.\n  }\n}\nvoid main() {\n  delay(1000); // Delay for 1 second.\n}\nIn AVR, the delay function is implemented using the Timer/Counter 1 (TCNT1) peripheral. TCNT1 is a 16-bit timer that can be used to measure time or to generate periodic interrupts.To use the delay function in AVR, you first need to initialize TCNT1. The following code initializes TCNT1 to count at a frequency of 1000 Hz (1 millisecond per count):Code snippet\nvoid init_timer1() {\n  TCCR1A = 0;\n  TCCR1B = 0;\n  TCNT1 = 0;\n  TCCR1B |= (1 << CS10); // Set the prescaler to 1.\n}\nOnce TCNT1 has been initialized, you can use the delay function to delay the program for a specified amount of time. The following code will delay the program for 1 second:Code snippet\nvoid delay_ms(unsigned int milliseconds) {\n  for (unsigned int i = 0; i < milliseconds; i++) {\n    while ((TIFR1 & (1 << TOV1)) == 0); // Wait for timer overflow.\n    TIFR1 |= (1 << TOV1); // Clear the timer overflow flag.\n  }\n}\nvoid main() {\n  init_timer1();\n  delay_ms(1000); // Delay for 1 second.\n}","11-explain-io-ports-and-assosiate-registers-in-avr#11) Explain io ports and assosiate registers in avr":"An I/O port is a group of pins on an AVR microcontroller that can be used to input or output data. Each port has three registers associated with it:\nData Direction Register (DDRx): This register determines whether the pins in the port are inputs or outputs.\nPort Register (PORTx): This register is used to read or write data to the pins in the port.\nInput Pins Address Register (PINx): This register is used to read the data from the pins in the port.\nTo configure a port as an input, you set the corresponding bit in the DDRx register to 0. To configure a port as an output, you set the corresponding bit in the DDRx register to 1. To read data from a port, you read the value of the PORTx register. To write data to a port, you write the desired value to the PORTx register.For example, to configure Port B as an output and write the value 0x01 to it, you would use the following code:Code snippet\nDDRB = 0x01;\nPORTB = 0x01;\nThis would set the first pin in Port B to be an output and write the value 0x01 to it.I/O ports are a fundamental part of AVR microcontrollers and are used for a wide variety of tasks, such as controlling LEDs, reading switches, and communicating with other devices.Here is a table that summarizes the functions of the three registers:\nRegister\tFunction\tDDRx\tConfigures the pins in the port as inputs or outputs.\tPORTx\tReads or writes data to the pins in the port.\tPINx\tReads the data from the pins in the port.","12-explain-toggle-port-bits-in-avr#12) Explain toggle port bits in avr":"Toggling a port bit in AVR means to change its state from 0 to 1 or from 1 to 0. This can be done by using the exclusive OR (XOR) operator. The XOR operator will toggle the state of the bit that it is applied to.For example, to toggle the first bit in Port A, you would use the following code:Code snippet\nPORTA ^= 1;\nThis would toggle the first bit in Port A, regardless of its current state.The XOR operator can also be used to toggle multiple bits in a port. For example, to toggle the first and third bits in Port A, you would use the following code:Code snippet\nPORTA ^= 3;\nThis would toggle the first and third bits in Port A, regardless of their current state.I hope this explanation is helpful. Let me know if you have any other questions.Here are some additional things to keep in mind when toggling port bits in AVR:\nThe XOR operator is a very efficient way to toggle a port bit. It only requires one instruction to execute, which is much faster than using other methods, such as setting or clearing the bit directly.\nThe XOR operator can be used to toggle multiple bits in a port at the same time. This can be useful for tasks such as controlling multiple LEDs or reading multiple switches.\nWhen toggling port bits, it is important to make sure that the port is configured as an output. If the port is configured as an input, toggling the bit will not have any effect.","13-explain-interrupt-and-steps-of-interrupt#13) Explain interrupt and steps of interrupt":"An interrupt is an event that causes the AVR microcontroller to stop what it is doing and execute a specific piece of code. Interrupts are used to handle events that happen outside of the control of the main program, such as a button press or a timer overflow.The steps of an interrupt in AVR are as follows:\nThe interrupt is triggered. This can happen when a specific event occurs, such as a button press or a timer overflow.\nThe AVR microcontroller saves the current state of the program. This includes the value of the program counter, the registers, and the status flags.\nThe AVR microcontroller jumps to the interrupt service routine (ISR). The ISR is a special piece of code that is used to handle the interrupt.\nThe ISR performs the necessary actions to handle the interrupt. This might include reading data from a sensor, writing data to a device, or performing a calculation.\nThe ISR returns from the interrupt. The AVR microcontroller restores the saved state of the program and continues executing the main program from where it left off.\nHere are some additional things to keep in mind about interrupts in AVR:\nInterrupts can be enabled or disabled. When an interrupt is disabled, the AVR microcontroller will not respond to that interrupt.\nInterrupts can be prioritized. This means that some interrupts can be handled more quickly than others.\nInterrupts can be nested. This means that an interrupt can occur while another interrupt is already being handled.\nI hope this explanation is helpful. Let me know if you have any other questions.Here are some examples of when interrupts might be used:\nTo handle button presses\nTo read data from sensors\nTo write data to devices\nTo perform calculations\nTo control motors\nTo communicate with other devices\nInterrupts can be a powerful tool for improving the responsiveness and efficiency of your AVR microcontroller programs.","14-explain-timer0-vs-timer1-vs-timer2-in-avr#14) explain timer0 vs timer1 vs timer2 in avr":"The AVR microcontroller has three timers, Timer0, Timer1, and Timer2. Each timer has its own registers and can be used for different purposes.Timer0 is a 8-bit timer, which means it can count from 0 to 255. Timer0 is often used for generating delays, generating pulses, and counting events. Timer0 can also be used to create a software-based real-time clock.Timer1 is a 16-bit timer, which means it can count from 0 to 65535. Timer1 is often used for generating more precise delays and pulses than Timer0. Timer1 can also be used for generating PWM signals, which are used to control the speed of motors and other devices.Timer2 is a 8-bit timer, but it has some features that Timer0 and Timer1 do not have. Timer2 can be used to generate asynchronous pulses, which means that the pulses will continue to be generated even when the microcontroller is in sleep mode. Timer2 can also be used to generate a watchdog timer, which is a timer that can be used to reset the microcontroller if it hangs or crashes.The following is a table that shows a comparison of the three timers:| Timer | Bits | Features ||---|---|---|| Timer0 | 8 | Simple, easy to use || Timer1 | 16 | More precise, can be used for PWM || Timer2 | 8 | Asynchronous, can be used for watchdog timer |","15-explain-timer-registers#15) Explain Timer(), registers":"Timer registers in AVR are used to control the timing of events in an AVR microcontroller. There are three timers in AVR: Timer 0, Timer 1, and Timer 2. Each timer has a number of registers that are used to control its operation.The main registers used in Timer 0 are:\nTCNT0: This register holds the current value of the timer counter.\nOCR0A: This register holds the value that the timer counter is compared to. When the timer counter reaches this value, an output compare interrupt is generated.\nOCR0B: This register is similar to OCR0A, but it generates an output compare interrupt on a different pin.\nTCCR0A: This register controls the mode of operation of Timer 0.\nTCCR0B: This register controls the clock source for Timer 0.\nThe main registers used in Timer 1 are:\nTCNT1H: This register holds the upper 8 bits of the timer counter.\nTCNT1L: This register holds the lower 8 bits of the timer counter.\nOCR1A: This register holds the value that the timer counter is compared to. When the timer counter reaches this value, an output compare interrupt is generated.\nOCR1B: This register is similar to OCR1A, but it generates an output compare interrupt on a different pin.\nICR1: This register holds the value of the timer counter at the time of an input capture event.\nTCCR1A: This register controls the mode of operation of Timer 1.\nTCCR1B: This register controls the clock source for Timer 1.\nThe main registers used in Timer 2 are:\nTCNT2: This register holds the current value of the timer counter.\nOCR2A: This register holds the value that the timer counter is compared to. When the timer counter reaches this value, an output compare interrupt is generated.\nTCCR2A: This register controls the mode of operation of Timer 2.\nTCCR2B: This register controls the clock source for Timer 2.\nThe Timer registers can be used to generate a variety of timing events, such as:\nPulse-width modulation (PWM)\nTime delays\nInput capture\nOutput compare interrupts\nThe Timer registers are a powerful tool that can be used to control the timing of events in an AVR microcontroller.","16-external-hardware-interrupt#16) External hardware interrupt":"An external hardware interrupt in AVR is a way to tell the microcontroller to stop what it's doing and jump to a special routine called an interrupt service routine (ISR). This is useful for things like detecting button presses, reading sensors, or communicating with other devices.To use an external hardware interrupt, you need to do the following:\nEnable the interrupt in the General Interrupt Control Register (GICR).\nConfigure the interrupt in the MCU Control Register (MCUCR).\nWrite an ISR to handle the interrupt.\nEnable global interrupts in the Status Register (SREG).\nHere is an example of how to configure an external hardware interrupt on pin INT0 to trigger on a rising edge:Code snippet\n// Enable the interrupt\nEICRA |= _BV(ISC01);\n// Configure the interrupt\nMCUCR |= _BV(ISC00);\n// Write the ISR\nvoid INT0_ISR(void) {\n  // Do something here when the interrupt is triggered\n}\n// Enable global interrupts\nsei();\nWhen the interrupt is triggered, the microcontroller will jump to the ISR. The ISR will then execute the code inside it before returning back to the main program.Here are some things to keep in mind when using external hardware interrupts:\nInterrupts can be triggered by a variety of things, such as button presses, sensor readings, or communication events.\nThe ISR should be as short as possible to avoid delaying the main program.\nIf multiple interrupts can be triggered at the same time, the microcontroller will handle them in the order in which they were triggered.\nExternal hardware interrupts are a powerful tool that can be used to improve the responsiveness and functionality of your AVR projects.","17-adc-characteristics-features-registers-in-avr#17) ADC characteristics, features, registers in avr":"The ADC (Analog-to-Digital Converter) is a peripheral on the AVR microcontroller that allows you to convert an analog voltage to a digital value. The ADC has a number of characteristics, features, and registers that you need to know about in order to use it effectively.CharacteristicsThe ADC has a number of characteristics that you need to be aware of, including:\nResolution: The resolution of the ADC is the number of bits that are used to represent the digital value. The higher the resolution, the more precise the digital value will be.\nAccuracy: The accuracy of the ADC is the amount of error that is introduced when converting the analog voltage to a digital value. The higher the accuracy, the closer the digital value will be to the actual analog voltage.\nConversion speed: The conversion speed of the ADC is the amount of time it takes to convert an analog voltage to a digital value. The faster the conversion speed, the more quickly you can take readings from the ADC.\nFeaturesThe ADC has a number of features that you can use to control the way it operates, including:\nConversion mode: The conversion mode determines how the ADC samples the analog voltage. The two main conversion modes are single-conversion mode and continuous-conversion mode.\nPrescaling: The prescaling factor determines how the ADC divides the analog voltage before it is converted. The higher the prescaling factor, the lower the resolution of the ADC will be.\nInterrupts: The ADC can generate interrupts when a conversion is complete. This can be useful for things like triggering other events or updating a display.\nRegistersThe ADC has a number of registers that you can use to control its operation, including:\nADMUX: The ADMUX register controls the ADC's operating mode, resolution, and prescaling factor.\nADCSRA: The ADCSRA register controls the ADC's clock speed, conversion mode, and interrupt enable.\nADCSRB: The ADCSRB register controls the ADC's trigger source and auto-triggering.\nADCH: The ADCH register stores the high byte of the digital value from the most recent conversion.\nADCL: The ADCL register stores the low byte of the digital value from the most recent conversion.","18-explain-rs232-atmega-connection-in-avr#18) explain rs232 Atmega connection in avr":"// Set the baud rateUBRR0 = UBRR_VALUE;// Set the data formatUCSR0C = (1 << UCSZ01) | (1 << UCSZ00);// Enable the USARTUCSR0B = (1 << TXEN0);// Transmit dataUDR0 = data;","29-temp-sensor-interfacing-in-avr#29) Temp sensor interfacing in avr":"// Set the ADC reference voltage to AVCCADMUX = (1 << REFS0);// Set the ADC prescaler to 128ADCSRA = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);// Set the ADC trigger mode to free runningADCSRA |= (1 << ADATE);// Start the ADC conversionADCSRA |= (1 << ADCSRA);// Wait for the ADC conversion to completewhile ((ADCSRA & (1 << ADSC)) == 1);// Read the ADC valueint adc_value = ADCH;// Convert the ADC value to a temperaturefloat temperature = (adc_value * 1.0) * 100.0 / 1024.0;// Print the temperatureSerial.println(temperature);","20-keyboard-interfacing#20) Keyboard interfacing":"// Set the scan rate to 100 Hzuint16_t scan_rate = 100;// Set the debouncing time to 50 msuint16_t debounce_time = 50;// Set the scan sequenceuint8_t scan_sequence[] = {0, 1, 2, 3};// Start scanning the keyboardwhile (1) {// Set the output pins highfor (uint8_t row = 0; row < 4; row++) {PORTD |= (1 << row);}// Wait for the scan ratedelay(scan_rate);// Read the input pinsfor (uint8_t col = 0; col < 4; col++) {uint8_t key_pressed = ((PIND & (1 << col)) == 0);// If a key is pressed, identify the keyif (key_pressed) {uint8_t key_code = scan_sequence[row] * 4 + col;// Do something with the pressed key}}// Set the output pins lowPORTD &= ~(0xF);}","21-explain-lcd-interfacing-in-avr#21) Explain LCD interfacing in avr":"Here are the steps on how to interface a Liquid Crystal Display (LCD) with an AVR microcontroller:Choose an LCD: There are many different types of LCDs available, so it is important to choose one that is suitable for your application. Some popular LCDs include the HD44780, the Hitachi HD44780, and the NEC µPD7263.Connect the LCD to the AVR microcontroller: The specific connections will vary depending on the type of LCD you are using. However, in general, the LCD will have 4 or more data lines, 2 or more control lines, and a backlight power connection. The data lines should be connected to the I/O pins on the AVR microcontroller, the control lines should be connected to the control pins on the AVR microcontroller, and the backlight power connection should be connected to the VCC pin on the AVR microcontroller.Configure the LCD: The LCD needs to be configured to display characters and to control the backlight. This can be done by sending commands to the LCD. The commands are sent by sending a series of bytes to the LCD, where each byte represents a command or data.Start displaying data on the LCD: Once the LCD is configured, you can start displaying data on the LCD. The data can be displayed by sending a series of bytes to the LCD, where each byte represents a character or a control code.Here is an example of how to display the text \"Hello, World!\" on an LCD using an AVR microcontroller:// Initialize the LCDlcd_init();// Set the cursor to the home positionlcd_home();// Display the text \"Hello, World!\"lcd_print(\"Hello, World!\");This code will initialize the LCD, set the cursor to the home position, and then display the text \"Hello, World!\" on the LCD","22-explain-dac-interfacing-in-avr#22) explain dac interfacing in avr":"// Set the DAC reference voltage to AVccADMUX = (1 << REFS0);// Set the DAC output range to full scaleADCSRA = (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);// Set the DAC output mode to continuousADCSRA |= (1 << ADATE);// Start generating the sine wavewhile (1) {// Calculate the next sample valueint sample_value = sin(2 * PI * micros() / 1000000);// Write the sample value to the DAC output pinDAC0 = sample_value;}","23-serial-communication-in-avr#23) serial communication in avr":"Serial communication is a method of transmitting data between two devices over a single wire. AVR microcontrollers have a built-in Universal Synchronous/Asynchronous Receiver Transmitter (USART) peripheral that can be used to communicate using the serial protocol.To communicate with another device using serial communication, the following steps need to be taken:Choose a serial communication protocol: There are many different serial communication protocols available, such as UART, I2C, and SPI. The most common serial communication protocol for AVR microcontrollers is UART.Connect the devices: The specific connections will vary depending on the type of serial communication protocol you are using. However, in general, the devices will need to be connected to the TXD and RXD pins of the USART peripheral on each device.Configure the USART: The USART needs to be configured to communicate at the desired baud rate, data format, and parity.","24-synchronous-and-asynchronous-advantages-of-avr#24) synchronous and asynchronous, advantages of avr":"here are some of the advantages of AVR microcontrollers:Synchronous and asynchronous: AVR microcontrollers can be used in both synchronous and asynchronous applications. Synchronous communication uses a clock signal to synchronize the data transfer between two devices. Asynchronous communication does not use a clock signal, and the data transfer is synchronized by start and stop bits.Low power: AVR microcontrollers are designed to be low power, which makes them ideal for battery-powered applications.Small size: AVR microcontrollers are available in a variety of packages, including QFN, TQFP, and DIP. The small size of AVR microcontrollers makes them ideal for embedded applications.Cost-effective: AVR microcontrollers are cost-effective, which makes them a popular choice for a wide range of applications.Here are some of the advantages of synchronous and asynchronous communication:Synchronous: Synchronous communication is more efficient than asynchronous communication because it does not require start and stop bits.Asynchronous: Asynchronous communication is more flexible than synchronous communication because it can be used with devices that do not have a clock signal.Here are some of the disadvantages of AVR microcontrollers:Limited memory: AVR microcontrollers have limited memory, which can be a limitation for some applications.Complex programming: AVR microcontrollers can be complex to program, which can be a barrier for some users.Not as widely used as other microcontrollers: AVR microcontrollers are not as widely used as other microcontrollers, such as PICs and ARM Cortex-M microcontrollers. This can make it difficult to find support and resources for AVR microcontrollers.Overall, AVR microcontrollers are a good choice for a wide range of applications. They are low power, small size, cost-effective, and can be used in both synchronous and asynchronous applications. However, they have some limitations, such as limited memory and complex programming.","25-general-purpose-registers-in-avr#25) general purpose registers in avr":"here are some of the general purpose registers in AVR:R0-R31: These are the general purpose registers. They can be used for any purpose, such as storing data, storing addresses, or storing the results of calculations.X, Y, Z: These are the index registers. They can be used to index into arrays or to access data in memory.SREG: This is the status register. It contains flags that indicate the status of the microcontroller, such as the carry flag, the zero flag, and the sign flag.PC: This is the program counter. It contains the address of the next instruction to be executed.SP: This is the stack pointer. It points to the top of the stack.The general purpose registers can be used for any purpose, but they are often used for specific tasks. For example, R16 and R17 are often used to store the values of the X and Y coordinates of a point, and R24 and R25 are often used to store the values of the width and height of a rectangle.The index registers are used to index into arrays or to access data in memory. For example, if you have an array of 10 elements, you can use the index registers to access any element in the array.The status register contains flags that indicate the status of the microcontroller. These flags can be used to check the results of calculations or to control the flow of execution.The program counter contains the address of the next instruction to be executed. It is incremented automatically by the CPU.The stack pointer points to the top of the stack. The stack is a region of memory that is used to store temporary data, such as the return address of a function call.","26-program-counter#26) program counter":"the program counter (PC) in an AVR microcontroller is a 16-bit register that stores the address of the next instruction to be executed. The PC is incremented automatically by the CPU after each instruction is executed. The PC can also be changed manually by using instructions such as CALL, RCALL, and RJMP.The PC is an important part of the AVR's instruction execution pipeline. The instruction execution pipeline is a series of steps that the CPU takes to execute an instruction. The PC is used to keep track of which step in the instruction execution pipeline the CPU is currently on.The PC is also used to implement subroutines and loops. A subroutine is a group of instructions that can be called from another part of the program. When a subroutine is called, the PC is saved onto the stack and the address of the subroutine is loaded into the PC. When the subroutine finishes executing, the PC is restored from the stack and execution resumes at the instruction that called the subroutine.A loop is a group of instructions that are executed repeatedly until a certain condition is met. When a loop is executed, the PC is loaded with the address of the loop's beginning. The loop will continue to execute until the condition is met, at which point the PC will be loaded with the address of the instruction after the loop.The PC is a critical part of the AVR microcontroller and it is essential for the correct execution of programs.Here are some of the instructions that can be used to change the PC:CALL: This instruction calls a subroutine. The address of the subroutine is pushed onto the stack and the PC is loaded with the address of the subroutine.RCALL: This instruction calls a subroutine and saves the return address onto the stack. The address of the subroutine is loaded into the PC.RJMP: This instruction jumps to a new location. The address of the new location is loaded into the PC.","27-lcd-pins-in-avr#27) Lcd pins in avr":"The LCD pins in AVR are used to control the LCD display. The number of pins used depends on the LCD display and the AVR microcontroller being used. In general, the LCD pins are used to:Select the data or command register: This is done by connecting the RS pin to either ground or Vcc.Write data to the LCD: This is done by connecting the RW pin to ground.Enable the LCD: This is done by connecting the E pin to Vcc.Select the data lines: This is done by connecting the D0-D7 pins to the appropriate data lines on the AVR microcontroller.","28-serial-vs-parallel#28) Serial vs parallel":"Serial Communication: Serial communication is a method of transmitting data between two devices over a single wire. The data is transmitted one bit at a time, with each bit being represented by a high or low voltage on the wire. Serial communication is slower than parallel communication, but it requires less hardware. It is ideal for long-distance communication, such as communication between a microcontroller and a computer over a USB cable.Parallel Communication: Parallel communication is a method of transmitting data between two devices over multiple wires. The data is transmitted simultaneously on all of the wires, with each wire representing a different bit. Parallel communication is faster than serial communication, but it requires more hardware. It is ideal for short-distance communication, such as communication between peripherals on the same board.","29-risc-in-avr#29) RISC in avr":"RISC stands for Reduced Instruction Set Computing. It is a type of instruction set architecture (ISA) that uses a small number of simple instructions. RISC ISAs are designed to be efficient, with each instruction taking a single clock cycle to execute.AVR microcontrollers use a RISC ISA. This means that they can execute instructions very quickly, which makes them ideal for applications where speed is important. For example, AVR microcontrollers are often used in embedded systems, such as cars, appliances, and toys.Here are some of the advantages of using a RISC ISA:\nSpeed: RISC ISAs can execute instructions very quickly, which makes them ideal for applications where speed is important.\nSimplicity: RISC ISAs are simpler than CISC ISAs, which makes them easier to design and implement.\nLow power: RISC ISAs consume less power than CISC ISAs, which makes them ideal for battery-powered applications.\nHere are some of the disadvantages of using a RISC ISA:\nLimited functionality: RISC ISAs have a limited number of instructions, which can make it difficult to implement complex algorithms.\nNot as widely used: RISC ISAs are not as widely used as CISC ISAs, which can make it difficult to find support and resources for RISC ISAs.\nOverall, RISC ISAs offer a number of advantages over CISC ISAs, including speed, simplicity, and low power consumption. These advantages make RISC ISAs ideal for a wide range of applications, including embedded systems, cars, appliances, and toys.Here are some of the specific features of the AVR RISC ISA that contribute to its speed and efficiency:\nSingle-cycle instructions: Most AVR instructions take a single clock cycle to execute. This is in contrast to CISC ISAs, where many instructions take multiple clock cycles to execute.\nRegister-based architecture: AVR instructions operate on registers, which are small pieces of memory that are directly accessible to the CPU. This makes AVR instructions faster than CISC instructions, which often operate on memory locations that are not directly accessible to the CPU.\nOrthogonal instruction set: The AVR instruction set is orthogonal, which means that any instruction can be used in any context. This makes AVR programs easier to write and maintain than programs for CISC processors, where certain instructions can only be used in certain contexts.\nThe combination of these features makes AVR microcontrollers one of the fastest and most efficient microcontrollers on the market."}},"/Cheat_sheets/cheat-sheet-git":{"title":"Reader's note. I think Git's UI is a clusterfuck","data":{"git#git":"$ g remote add origin https://darllxd@github.com/ueccssrnd/name-of-project.git\n$ g remote set-url origin git://new.url.here\nCheck last 2 diffs: g log -p -2 \nCancel last commit: git reset --soft HEAD~1. Then you can do a gre (git reset --hard HEAD && git clean -f) after. So this \"cancels a commit\".","you-pushed-a-wrong-commit-message#You pushed a wrong commit message.":"$ git reset --soft head~\n$ git commit -m \"new commit message\"\n$ git push -f","branches#Branches":"View remote\n$ git branch -r\nView all\n$ g branch -a\nCheck last commit of each branch\n$ git branch -v\nPull from remote the branch fix_stuff\n$ g checkout -b fix_stuff origin/fix_stuff","deleting#Deleting":"$ g branch -d local_branch_to_be_deleted\n# $ g push [REMOTE] :[NAME_OF_REMOTE_BRANCH]\n$ g push origin :facebook_integration\nPull from remote but different branch\n$ g pull [remote_location] [remote_branch]\n$ g pull origin master\nCloning from BB\n$ g clone https://daryllxd@bitbucket.org/icanpassaccounting/icpa.git icpa_redesign","aliases-desu-for-add--commit#ALIASES-DESU for add + commit":"$ g config --global alias.add-commit '!g add -A && g commit'","aliases-desu-for-last#ALIASES-DESU for last":"$ g config --global alias.last ’log -1 HEAD’","heroku#heroku":"$ heroku addons:add heroku-postgresql:dev\n$ heroku pg:promote HEROKU_POSTGRESQL_BROWN\n$ heroku apps:destroy app-to-be-destroyed\nSee more at: http://blog.tacticalnuclearstrike.com/2012/07/sinatra-on-heroku/#sthash.gVoDFq4u.dpufRevert to last commit: g reset --hard HEAD\nRemove untracked shit: g clean -fd"}},"/Books/48-laws-of-power":{"title":"48 Laws of Power -- Robert Greene","data":{"":"Never Outshine the Master.\nGalileo was clever - he dedicated his discover of the moons of Jupiter to the Medicis, since the royal symbol of the Medici family was the planet Jupiter.Wisdom in a nutshell:\nPresent your ideas in such as manner that they may be ascribed to your master, or could be viewed as an echo of your master's thoughts.\nIf you are more intelligent than your master, act as if you are not.\nNever take your position for granted.\nNever let favors you receive go to your head.\nDiscreet flattery is much more powerful. Make it seem like you want to seek his expertise and advise.\nNever Put Too Much Trust in Friends, Learn how to use Enemies.\nWisdom in a nutshell:\nFriends will never be totally honest with you. They will not openly disagree to avoid arguments.\nEnemies expect nothing so they will be surprised when you are generous.\nAn enemy spared the guillotine will be more grateful to you than a friend.\nWhen you decide to hire a friend you will discover qualities she has kept hidden.\nSkill and competence are more important than friendly feelings.\nHiring friends will limit your power.\nAll working situations require a distance between people.\nYou destroy an enemy when you make a friend of him.\nAn enemy at your heels keeps you sharp, alert, and focused.\nConceal your Intentions.\nAfter Marquis' admission of love, the countess no longer found him interesting and avoided him.Wisdom in a nutshell:\nUse decoyed objects of desire and red herrings to throw people off scent.\nUse smoke screens (a poker face) to disguise your actions.\nFalse sincerity is one powerful tool that will send your rivals on a wild goose chase.\nBlend in and people will be less suspicious.\nAlways say less than necessary.\nThe less Marcel Duchamp talked about his work, the more it was talked about in the art circles. When interviewed, Andy Warhol would give vague and ambiguous answers and let the interviewer find his own interpretation.Wisdom in a nutshell:\nSaying less will keep you from saying something foolish or even dangerous.\nKeeping silent makes people reveal more about themselves.\nSo much depends on reputation -- guard it with your life.\nUse humor or gentle mockery at your rival's expense.\nA solid reputation increases your presence and exaggerates your strengths without your having to spend much energy.\nNever appear desperate in your self-defense against the slander of others.\nBe careful not to go too far in attacking another's reputation.\nCourt attention at all cost.\nSurround your name with the sensational and the scandalous.\nCreate an air of mystery.\nIt is better to be attacked ans slandered than ignored.\nMake yourself appear larger than life.\nAny sort of notoriety will bring you power.\nGet others to do the work for you, but always take the credit.\nSave time and energy by hiring others to do the work.\nYou can only exploit others' talents if your position is unshakeable.\nMake other people come to you -- use bait if necessary.\nFor negotiations and meetings, it is wiser to lure others into your territory, or a territory of your choice.\nOnce someone suspects you are manipulating him, it will be harder to control him. Making him come to you gives the illusion he is control.\nMost often the effective action is to stay back, keep calm, and let others be frustrated by the traps you set for them.\nWin through your actions, never through argument.\nBy asking his patron to look at his sculpture's nose through a different perspective, while pretending to correct the nose, the mayor was convinced the nose looked much better. Michelangelo succeeded in making Soderini think his comment had helped improve the work.\nDemonstrate, do not explicate.\nArguing will only offend your superior.\nLearn to demonstrate the correctness of your ideas indirectly.\nDon't bother demonstrating if time and experience will eventually teach the other person what you are trying to say. Save your energy and walk away.\nNo one can argue with a demonstrated proof.\nInfection: Avoid the unhappy and unlucky.\nIn the game of power, the people you associate with are critical.\nAn infector can be recognized by the misfortune they draw on themselves, broken relationships, unstable careers.\nGravitate towards prosperous, cheerful, and gregarious people.\nNever associate with those who keep your defects.\nLearn to keep people dependent on you.\nMichelangelo knew he could always find another patron, but the pope knew he could not find another Michelangelo.Machiavelli said it is better to be feared than loved. Fear can be controlled; love, never.\nBe the only one who can do what you do. Make the fate of those who hire you so entwined with yours they cannot possibly get rid of you.\nIf you are ambitious, it is wiser to seek out weak masters with whom you can create a relationship of dependency.\nPossess a talent or creative skill that sets you apart from the crowd.\nBy knowing other people's secrets and holding information they wouldn't want made public, you seal your fate with theirs.\nUse selective honesty and generosity to disarm your victim.\nThe essence of deception is distraction. An act of kindness, generosity, or honesty will distract and disarm people and turn them into gullible children.\nGive before you take.\nNothing in the realm of power is set in stone. Overt deceptiveness may sometimes cover your tracks. If you have a history of deceit behind you, then play the rogue, be consistent and this will be interpreted as you simply being yourself.\nWhen asking for help, appeal to people's self-interest, never to their mercy or gratitude.\nWhen Genghis Khan conquered China, his adviser Yelu Ch'u-Ts'ai persuaded him to reap the benefits of their new territory by taxing its people.Most people are very pragmatic. Do not bring the need for gratitude for what you have done for others in the past. These appeals will be ignored. Pragmatic people look towards the future, so it is best to emphasize how they will benefit from an alliance with you.\nUnderstand the other person's motivation.\nFor others who want to feel superior and do not want to appear selfish, appeal to their need to display their charity in the public eye.\nPose as a friend, work as a spy.\nJoseph Duveen monopolized the art-collecting market through his ingenious spying tactics. He would place the household employees of his potential clients on his own payroll to provide information. He would arrange accidental meetings in elevators to lead his wealthy patrons into his trap.\nGather information at social events when people's guards are down.\nUse other people to give you the information you need.\nMislead others by giving out false information. Watch them react and base your next action on what you discover.\nCrush your enemy totally.\nShow no mercy. Crush your rivals or else you give them time to regroup and plot their revenge.\nBanish enemies or plot for the est time to render them harmless.\nLeave your enemies no options.\nSometimes enemies will destroy themselves.\nThoughts of reconciliation will open you up to attack.\nUse absence to increase respect and honor.\nCreate value through scarcity. Make yourself less accessible, otherwise the aura you have created around yourself will wear away.\nKeep others in suspended terror: Cultivate an air of unpredictability.\nA person of power instills fear by deliberately unsettling those around him to keep the initiative on his side.\nOnly the terminally subordinate act in a predictable manner.\nDo not build fortresses to protect yourself - isolation is dangerous.\nKing Louis XIV knew that if he were to isolate himself for one moment, conspiracies would rise behind his back.\nA fortress may be impregnable, but everyone knows you are there and it may turn into a prison.\nPower depends on social interaction and circulation.\nIsolation is deadly for the creative arts. Shakespeare constantly produced plays for the masses.\nMobility and social contact protects you from plotters.\nKnow who you're dealing with -- do not offend the wrong person.\nLearn to distinguish from opponent, sucker, and victim. Five dangerous marks: arrogant/proud, hopelessly insecure, suspicious, serpent with long memory, and the plain, unassuming, unintelligent man.\nMeasure up your opponent, but never rely on instinct. Do research on concrete facts about that person's character and history.\nNever trust appearances.\nDo not commit to anyone.\nQueen Elizabeth I dangled the possibility of marriage to all those who courted her. She forged alliances with the countries her suitors came from.\nBy refusing to commit, but allowing yourself to be courted, you become powerful because you are ungraspable.\nAs your reputation for independence grows, more people will desire you and want to conquer you.\nPolitely decline. You cannot allow yourself to feel obligated to anyone.\nSeek promises from both sides, so no matter what the outcome of a battle, your position is secure.\nObserve quarreling parties and stay neutral but supportive to both sides. Gain power as a mediator.\nYou may commit to one to prove you are capable of attachment, but be emotionally uninvolved. Preserve the unspoken option of being able to leave anytime and reclaim your freedom.\nPlay a sucker to catch a sucker -- seem dumber than your mark.\nIntelligence is an important part of people's vanity. Subliminally reassure your opponent of his superiority.\nPlaying naive lets you see opportunities to deceive others.\nUse the surrender tactic: transform weakness into power.\nDo not fight aggression with aggression. Put your opponent off-guard by yielding, and in effect have more control over the situation.\nSurrender is a way of mocking your enemies.\nSurrender disguises your real motives and allows time to plan your next move.\nConcentrate your forces.\nThe Rothschild banking family concentrated its wealth within a very tight-knit structure. Five brothers each controlled a part of the empire from Paris, Frankfurt, Vienna, Naples, to London.\nSingle-mindedness of purpose and total concentration on one goal will overwhelm the enemy every time.\nA single patron appreciates your loyalty and becomes dependent on your services.\nIn the arts, being too single-minded can make you an intolerable bore.\nPlay the perfect courtier.\nTalk less about yourself. Modesty is generally preferable.\nPractice nonchalance. All your hard work must come off as effortless.\nBe frugal with flattery.\nArrange to be noticed.\nAlter your style and language according to the person you are dealing with.\nNever be the bearer of bad news.\nNever affect friendliness and intimacy with your master.\nNever criticize those above you directly.\nBe frugal in asking those above you for favors.\nNever joke about appearances or taste.\nDo not be the court cynic.\nBe self-observant.\nMaster your emotions.\nFit the spirit of the times.\nBe a source of pleasure.\nRe-create yourself.\nJulius Caesar always incorporated drama and theatrics in his speeches and daily appearances. He was a great public showman, timing his entrances and exits, sponsoring extravagant spectacles, gladiator shows and theatrical events. The masses loved him, but his rivals feared him.Aurore Dupin Dudevant assumed the pseudonym George Sand. She dressed in men's breeches, smoked cigars, and expressed herself in conversation like a man. She even carried on affairs with the most famous artists of Europe.\nControl your appearances and emotions. Play sincere, but not necessarily be sincere.\nCreate a memorable character. Do not limit yourself to the role society assigns you.\nKeep your hands clean.\nCleopatra was always able to get people to do her bidding without them realizing she was manipulating them.\nConceal your mistakes. Your good name and reputation depends more on what you conceal than on what you reveal.\nAlways have a convenient scapegoat.\nNever do the dirty work yourself.\nPlay on people's need to believe to create a cult-like following.\nKeep it simple, keep it vague. Create new words for vague concepts.\nEmphasize the visual and sensual over the intellectual.\nBorrow the forms of organized religion to structure the group. Create rituals. Use names and ranks and titles. Ask them to make sacrifices and give alms. Act like a guru or a prophet.\nDisguise your source of income.\nSet up an us-versus-them dynamic. Keep followers united by identifying outsiders as a devious enemy.\nThe tendency to doubt and reason is broken down when we join a group.\nEnter action with boldness.\nBoldness strikes fear; fear creates authority.\nGoing halfway digs the deeper grave. Do not negotiate if your opponent will more likely take the opportunity to destroy you.\nHesitation creates gaps. Boldness obliterates them. Move swiftly and surely.\nAudacity separates you from the herd.\nPlan all the way to the end.\nTake into account all possible obstacles and circumstances that may prevent you from achieving your goal, and plan how you will overcome them.\nWhen you see several steps ahead, you will no longer need to improvise along the way, and risk deviating from your plan.\nPrepare alternatives and be open to adapt new routes to your goal.\nMake your accomplishments seem effortless.\nSen no Rikyu was an important tea master and adviser on aesthetic and political matters to the emperor Hideyoshi. He despised hosts who looked like they were trying too hard. Cha-no-yu is an art form and the whole process must look natural and easy.\nWhat imitates nature by appearing effortless and natural approximates nature's power.\nNever show work until it is finished. When people see the effort and time it takes to make it, and if they witness a work-in-progress, the magic of the final piece is spoiled.\nControl the options: Get others to play with the cards you deal.\nMake people your puppets and give them options to let them feel they have control. Force them to choose between the lesser of two evils, both of which serve your purpose.\nPresent options but color the one you prefer as the best solution.\nForce the resister into \"choosing\" to do what you want by appearing to advocate the opposite.\nAlter the playing field so the only options available are the ones you offer.\nShrinking options force people to buy in now or else the goods won't be available tomorrow.\nThe weak man must be propelled into action through fear and terror.\nInvolving your victim in your scheme with the threat of their exposure later will keep them tied to you. They cannot expose you because you will be found out as well.\nUse the horns of a dilemma: whichever way they choose, there is no escape.\nPlay to people's fantasies.\nAbraham Lincoln created an image of himself as the homespun country lawyer with a beard. He played to the fantasy of the common man's president.\nPeople need a fantasy to escape from the humdrum of everyday life. The more vague and exciting, the more captivating.\nPromise a pot of gold and instant gratification, rather than a gradual improvement through hard work.\nKeep your distance so the fantasy remains intact.\nDiscover each man's thumbscrew.\nEvery person has a weakness or insecurity you can use to your advantage.\nTrain yourself to probe for weaknesses in everyday conversation.\nFind the childhood need that went unfulfilled, supply it, and your victim will be unable to resist you.\nPeople's weaknesses are the opposite of the qualities they reveal to you. Shy people are actually dying for attention, a prude may be hiding a lascivious soul.\nBe royal in your own fashion: Act like a king to be treated like one.\nHow you carry yourself reflects what you think of yourself. Exude confidence and the feeling you were destined for greatness.\nDo not confuse regal bearing with arrogance.\nDignity is the mask you assume under difficult circumstances. Act like nothing can affect you and you have all the time in the world to respond.\nSet your price high and do not waver.\nDeal with the highest person in the building.\nA gift is an equalizer. You do not be but ask for help in a dignified way.\nMaster the art of timing.\nTime is a human-made concept. Long time: years-long period of waiting for the right opportunity while creating a strong foundation to work on. Forced time: upsetting the timing of others and setting their deadlines for them (easier to make mistakes). End time: execute a plan for speed and absolutely no hesitation.\nNever look as though you are in a hurry. It betrays a lack of control.\nLearn to stand back and be patient. Strike only when the time is right.\nRecognizing the prevailing winds does not necessarily mean running with them.\nDisdain things you cannot have: ignoring them is the best revenge.\nThe more attention you pay an enemy, the stronger you make him. The less interest you show, the more superior you seem.\nYou choose to let things bother you. You can just as easily choose to consider the matter trivial and unworthy of interest. That is the powerful move.\nIf it is impossible to ignore, then secretly get rid of it. Sometimes, threats just go away by themselves.\nCreate compelling spectacles.\nNever neglect the way you arrange things visually.\nAssociate yourself with colors, images, and symbols that communicate strong messages.\nPeople are always impressed by the superficial appearance of things, the grand, the spectacular, what is larger than life.\nThink as you are but behave like others.\nWise and clever peopel learn early on that they can display conventional behavior and mouth conventional ideas without having to believe in them.\nPut on the mask appropriate to the group you are joining.\nStir up waters to catch fish.\nAnger and emotion are strategically unproductive. Make your enemies angry but stay calm yourself.\nAngry people usually end up looking ridiculous.\nNothing in the game of power is personal.\nAn occasional outburst may be powerful, but use anger too often and it loses its power.\nDespise the free lunch.\nBy paying your own way, you stay free of gratitude. What is offered for free normally has a hidden obligation.\nGenerosity is a sign of power. Most people spend freely and are not misers.\nUse money as a way to give pleasure to others and win them over.\nAvoid stepping into a great man's shoes.\nChoose a different path and personal style if you are the daughter or son of a great person. You will forever be in your predecessor's shadow unless you find a way to shine on your own.\nOnly after the father figure has been done away with will there be space to establish a new order.\nDo not become complacent once you reach success and security. Prosperity makes us lazy.\nStrike the shepherd and the sheep will scatter.\nRecognize troublemakers by their complaining nature. Separate him from the group.\nIn every group, power is concentrated in the hands of one or two people. Human nature shows people will orbit around a single strong personality.\nWork on the hearts and minds of others.\nAim at the primary emotions: love, hate, jealousy. Be alert to people's individual psychologies and their basic emotional responses.\nMaintain a stable of artists, writers, and intellectuals who are very good at appealing to people's hearts and minds.\nDisarm and infuriate with the mirror effect.\nDo what your enemies do, follow their actions and they will not see what you are up to. When you mirror them, it mocks and humiliates them. Mimicry infuriates.\nThe Shadow effect: Shadow your opponents' every move, gather information, and gain insight to their routines and habits without them seeing you.\nThe Mirror effect: Show you understand by reflecting their innermost feelings.\nThe Moral effect: Teach others a lesson by giving them a taste of their own medicine.\nThe Hallucinatory effect: Offer a perfect copy of an object, place or person and see how people take the bait.\nPreach the need for change, but never reform too much at once.\nMake change and reform seem like such as gentle improvement on the past. People are creatures of habit and the sudden change will cause some to rebel.\nDisguise change by dressing it in tradition.\nNever appear too perfect.\nNever underestimate the power of envy. Occasionally reveal a weakness, defect, anxiety, or find new friends. It is in your own circle of peers who will be the first to envy your success.\nEnvy is often a problem for people who have great natural talent. You think you charm other people when in fact they hate you for it.\nTo deflect envy, employ a display of weakness, or a harmless vice.\nEnvy is disguised sometimes as excessive praise, or slander and criticism. Win your revenge by ignoring the envious.\nReversal: Display the utmost disdain for those who envy you. Instead of hiding your perfection, make it obvious. Make every triumph an opportunity to make the envious squirm.\nDo not go past the mark you aimed for; in victory, learn where to stop.\nThe powerful know that the essence of strategy is controlling what comes next.\nThere is no better time to stop and walk away than after a victory.\nAssume formlessness.\nAccept the fact that nothing is certain and no law is fixed. Be as fluid and formless as water, adapting and moving with change naturally.\nThe powerful are creative in expressing something new.\nPlay the chameleon but break your enemy from the inside.\nMorph and adapt but keep your long-term strategy in mind at all times."}},"/":{"title":"Vipin's Blog","data":{"":"Welcome to my Blog! Here i share everything that I love :)"}}}